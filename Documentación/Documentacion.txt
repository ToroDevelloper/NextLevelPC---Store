lo que queda faltando es:
- el login que no se logea correctamente, ósea inicia pero seria buen de que al logiarse se muestre el nombre del usuario que se logio o algo asi,y un apartado para el perfil

-la organización de productos algo como mas dinamico de manera horizontal con Carruseles o algo asi y cosas asi…

- también falta poner iconos mas reales en la parte de abajo, como los logos de Facebook, Instagram, etc para que se vea mas profesional

- falta la de ver destalle del producto y lo mismo con servicios (que solo permita ver si esta logiado, lo mismo cuando quiera añadirlo al carrito)

- Al logiarse como admin que haya una opcion de subir productos desde la interfaz para hacerlo de manera mas rapida.









### Funcionalidades Implementadas (Resumen)

1.  **Detalle de Servicios:**
    *   Se creó una página de detalles para cada servicio, accesible al hacer clic en una tarjeta de servicio.
    *   La página muestra el nombre, descripción, precio e imagen del servicio.

2.  **Imágenes en Servicios:**
    *   Se añadió un campo `imagen_url` a la tabla `servicios` en la base de datos.
    *   Las imágenes se muestran tanto en la lista de servicios como en la página de detalles.
    *   Si un servicio no tiene imagen, se muestra una imagen por defecto.

3.  **Carrito de Compras para Servicios:**
    *   Se implementó un contexto de carrito (`CartContext`) que persiste en `localStorage`.
    *   El botón "Añadir al carrito" en las tarjetas de servicio ahora agrega el servicio al carrito.
    *   El `Navbar` se ha integrado con el `CartContext` para mostrar los artículos, la cantidad y el total.

4.  **Agendamiento de Citas para Servicios a Domicilio:**
    *   En la página de detalles del servicio, el botón "Contratar Servicio" abre un formulario modal.
    *   El formulario permite al cliente ingresar sus datos (nombre, email, teléfono, dirección), seleccionar una fecha y describir el problema.
    *   Se ha creado un nuevo endpoint en el backend (`POST /api/citas-servicios`) y una tabla `citas_servicios` en la base de datos para guardar estas solicitudes.

- Roles y flujo de acceso:
  - Se reforzó la idea de que el cliente (rol `cliente`) navega el SPA (Home, Servicios, Productos, Perfil simple) y puede agendar servicios desde ahí.
  - Empleados y administradores (`empleado`, `admin`) están pensados para entrar directamente a las vistas EJS protegidas (dashboard y vistas de gestión), donde ven las solicitudes de servicio.
  - Se ajustó y documentó el uso de middlewares de vistas (`viewAuth`, `roleMiddleware`) y el comportamiento esperado al iniciar sesión.

- Perfil:
  - Se dejó un perfil sencillo en el SPA (`Perfil.jsx`) que muestra información del usuario logueado.
  - Se descartó mantener un perfil duplicado dentro de las vistas EJS para evitar confusión.

- Base de datos (archivo `nextlevel.sql`):
  - Se consolidó la estructura de la base de datos en `Documentación/nextlevel.sql`.
  - Cambios clave utilizados hoy:
    - Tabla `servicios` ahora incluye la columna `imagen_url` para mostrar imágenes de servicios.
    - Creación de la tabla `citas_servicios` para guardar las solicitudes de servicio a domicilio.
    - Creación de la tabla `refresh_tokens` para manejar tokens de refresco en el sistema de autenticación.

### Referencia técnica: SQL usado hoy

Estos son los comandos SQL que agregan o modifican la base de datos relacionados con lo trabajado hoy. Todos están consolidados en `Documentación/nextlevel.sql`.

1) Creación de la base de datos y uso

```sql
CREATE DATABASE IF NOT EXISTS `nextlevel` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */;
USE `nextlevel`;
```

2) Tabla `servicios` con columna `imagen_url`

```sql
CREATE TABLE IF NOT EXISTS `servicios` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `nombre` varchar(200) NOT NULL,
  `precio` decimal(12,2) NOT NULL,
  `descripcion` text DEFAULT NULL,
  `imagen_url` varchar(255) DEFAULT NULL,
  `activo` tinyint(1) DEFAULT 1,
  `ordenes_id` int(11) DEFAULT NULL,
  `tipo` enum('basico','avanzado') DEFAULT 'basico',
  PRIMARY KEY (`id`),
  KEY `ordenes_id` (`ordenes_id`),
  CONSTRAINT `servicios_ibfk_1` FOREIGN KEY (`ordenes_id`) REFERENCES `ordenes` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
```

> Nota: si ya existía la tabla `servicios` sin `imagen_url`, se podría añadir manualmente así (solo si llega a faltar):
>
> ```sql
> ALTER TABLE `servicios`
>   ADD COLUMN `imagen_url` varchar(255) DEFAULT NULL AFTER `descripcion`;
> ```

3) Tabla `citas_servicios` (solicitudes de servicio a domicilio)

```sql
CREATE TABLE IF NOT EXISTS `citas_servicios` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `servicio_id` INT(11) NOT NULL,
  `nombre_cliente` VARCHAR(255) NOT NULL,
  `email_cliente` VARCHAR(255) NOT NULL,
  `telefono_cliente` VARCHAR(50) NOT NULL,
  `direccion_cliente` TEXT NOT NULL,
  `fecha_cita` DATETIME NOT NULL,
  `descripcion_problema` TEXT DEFAULT NULL,
  `estado` ENUM('pendiente', 'confirmada', 'cancelada', 'completada') NOT NULL DEFAULT 'pendiente',
  `created_at` TIMESTAMP NULL DEFAULT current_timestamp(),
  PRIMARY KEY (`id`),
  KEY `servicio_id` (`servicio_id`),
  CONSTRAINT `citas_servicios_ibfk_1` FOREIGN KEY (`servicio_id`) REFERENCES `servicios` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
```

4) Tabla `refresh_tokens` (tokens de refresco para autenticación)

```sql
CREATE TABLE `refresh_tokens` (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    token VARCHAR(512) NOT NULL UNIQUE,
    expires_at DATETIME NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES usuarios(id) ON DELETE CASCADE ON UPDATE CASCADE,
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
```

> Nota: si la tabla ya existe, no es necesario volver a ejecutar este comando.

---

### Ejemplo de petición en Postman: crear una cita de servicio

Endpoint backend:
- Método: `POST`
- URL: `http://localhost:3000/api/citas-servicios` (ajusta el puerto según tu backend)
- Headers recomendados:
  - `Content-Type: application/json`

Body (JSON) de ejemplo:

```json
{
  "nombre": "Angel",
  "email": "cliente@example.com",
  "telefono": "4498489498",
  "direccion": "Calle Ejemplo 123, Colonia Centro",
  "fecha": "2025-11-14T18:38",
  "descripcion": "La computadora se apaga sola y va muy lenta.",
  "servicio_id": 1
}
```

Comportamiento esperado:
- El backend debe:
  - Validar los campos.
  - Crear un registro en la tabla `citas_servicios` con estado inicial `pendiente`.
  - Retornar `201 Created` o `200 OK` con la cita creada en el `body` de la respuesta.

Este mismo formato de JSON es el que se usa cuando el formulario en la página de detalle de un servicio (SPA React) dispara la solicitud al endpoint `/api/citas-servicios`.

---

15-11-2025
- Frontend: se unificó el manejo de imágenes por defecto en el módulo de productos y en los productos destacados de Home.
  - En `Productos.jsx` se usa una imagen placeholder cuando el producto no tiene imagen o la URL falla (onError), evitando íconos de imagen rota.
  - En `Home.jsx` (carrusel de productos destacados) se aplicó la misma lógica de placeholder y onError para `imagen_principal`.

15-11-2025 (actualización Home y Productos)
- Frontend: ajustes en productos destacados (Home) y detalle de productos.
  - En `Home.jsx` se eliminaron los iconos de "ojo" y el texto/botón "Ver Detalles" dentro de cada tarjeta de producto destacado, dejando las cards como elementos visuales limpios.
  - Ahora en `Home.jsx` cada tarjeta de producto destacado es clicable y redirige a `/productos/:id`, reutilizando la misma ruta de detalle que el módulo de productos.
  - En `Productos.jsx` se separó la vista en dos modos:
    - Modo lista (`/productos`): muestra el grid de productos y cada card es clicable para ir al detalle del producto.
    - Modo detalle (`/productos/:id`): muestra solo la información del producto seleccionado (imagen, nombre, precio, stock) usando el endpoint `/api/productos/:id`.
  - Se mantiene el uso de la imagen placeholder cuando falla la carga de la imagen real del producto.
