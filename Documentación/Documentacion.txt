lo que queda faltando es:
- el login que no se logea correctamente, ósea inicia pero seria buen de que al logiarse se muestre el nombre del usuario que se logio o algo asi,y un apartado para el perfil

-la organización de productos algo como mas dinamico de manera horizontal con Carruseles o algo asi y cosas asi…

- también falta poner iconos mas reales en la parte de abajo, como los logos de Facebook, Instagram, etc para que se vea mas profesional

- falta la de ver destalle del producto y lo mismo con servicios (que solo permita ver si esta logiado, lo mismo cuando quiera añadirlo al carrito)

- Al logiarse como admin que haya una opcion de subir productos desde la interfaz para hacerlo de manera mas rapida.









### Funcionalidades Implementadas (Resumen)

1.  **Detalle de Servicios:**
    *   Se creó una página de detalles para cada servicio, accesible al hacer clic en una tarjeta de servicio.
    *   La página muestra el nombre, descripción, precio e imagen del servicio.

2.  **Imágenes en Servicios:**
    *   Se añadió un campo `imagen_url` a la tabla `servicios` en la base de datos.
    *   Las imágenes se muestran tanto en la lista de servicios como en la página de detalles.
    *   Si un servicio no tiene imagen, se muestra una imagen por defecto.

3.  **Carrito de Compras para Servicios:**
    *   Se implementó un contexto de carrito (`CartContext`) que persiste en `localStorage`.
    *   El botón "Añadir al carrito" en las tarjetas de servicio ahora agrega el servicio al carrito.
    *   El `Navbar` se ha integrado con el `CartContext` para mostrar los artículos, la cantidad y el total.

4.  **Agendamiento de Citas para Servicios a Domicilio:**
    *   En la página de detalles del servicio, el botón "Contratar Servicio" abre un formulario modal.
    *   El formulario permite al cliente ingresar sus datos (nombre, email, teléfono, dirección), seleccionar una fecha y describir el problema.
    *   Se ha creado un nuevo endpoint en el backend (`POST /api/citas-servicios`) y una tabla `citas_servicios` en la base de datos para guardar estas solicitudes.

- Roles y flujo de acceso:
  - Se reforzó la idea de que el cliente (rol `cliente`) navega el SPA (Home, Servicios, Productos, Perfil simple) y puede agendar servicios desde ahí.
  - Empleados y administradores (`empleado`, `admin`) están pensados para entrar directamente a las vistas EJS protegidas (dashboard y vistas de gestión), donde ven las solicitudes de servicio.
  - Se ajustó y documentó el uso de middlewares de vistas (`viewAuth`, `roleMiddleware`) y el comportamiento esperado al iniciar sesión.

- Perfil:
  - Se dejó un perfil sencillo en el SPA (`Perfil.jsx`) que muestra información del usuario logueado.
  - Se descartó mantener un perfil duplicado dentro de las vistas EJS para evitar confusión.

- Base de datos (archivo `nextlevel.sql`):
  - Se consolidó la estructura de la base de datos en `Documentación/nextlevel.sql`.
  - Cambios clave utilizados hoy:
    - Tabla `servicios` ahora incluye la columna `imagen_url` para mostrar imágenes de servicios.
    - Creación de la tabla `citas_servicios` para guardar las solicitudes de servicio a domicilio.
    - Creación de la tabla `refresh_tokens` para manejar tokens de refresco en el sistema de autenticación.

### Referencia técnica: SQL usado hoy

Estos son los comandos SQL que agregan o modifican la base de datos relacionados con lo trabajado hoy. Todos están consolidados en `Documentación/nextlevel.sql`.

1) Creación de la base de datos y uso

```sql
CREATE DATABASE IF NOT EXISTS `nextlevel` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */;
USE `nextlevel`;
```

2) Tabla `servicios` con columna `imagen_url`

```sql
CREATE TABLE IF NOT EXISTS `servicios` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `nombre` varchar(200) NOT NULL,
  `precio` decimal(12,2) NOT NULL,
  `descripcion` text DEFAULT NULL,
  `imagen_url` varchar(255) DEFAULT NULL,
  `activo` tinyint(1) DEFAULT 1,
  `ordenes_id` int(11) DEFAULT NULL,
  `tipo` enum('basico','avanzado') DEFAULT 'basico',
  PRIMARY KEY (`id`),
  KEY `ordenes_id` (`ordenes_id`),
  CONSTRAINT `servicios_ibfk_1` FOREIGN KEY (`ordenes_id`) REFERENCES `ordenes` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
```

> Nota: si ya existía la tabla `servicios` sin `imagen_url`, se podría añadir manualmente así (solo si llega a faltar):
>
> ```sql
> ALTER TABLE `servicios`
>   ADD COLUMN `imagen_url` varchar(255) DEFAULT NULL AFTER `descripcion`;
> ```

3) Tabla `citas_servicios` (solicitudes de servicio a domicilio)

```sql
CREATE TABLE IF NOT EXISTS `citas_servicios` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `servicio_id` INT(11) NOT NULL,
  `nombre_cliente` VARCHAR(255) NOT NULL,
  `email_cliente` VARCHAR(255) NOT NULL,
  `telefono_cliente` VARCHAR(50) NOT NULL,
  `direccion_cliente` TEXT NOT NULL,
  `fecha_cita` DATETIME NOT NULL,
  `descripcion_problema` TEXT DEFAULT NULL,
  `estado` ENUM('pendiente', 'confirmada', 'cancelada', 'completada') NOT NULL DEFAULT 'pendiente',
  `created_at` TIMESTAMP NULL DEFAULT current_timestamp(),
  PRIMARY KEY (`id`),
  KEY `servicio_id` (`servicio_id`),
  CONSTRAINT `citas_servicios_ibfk_1` FOREIGN KEY (`servicio_id`) REFERENCES `servicios` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
```

4) Tabla `refresh_tokens` (tokens de refresco para autenticación)

```sql
CREATE TABLE `refresh_tokens` (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    token VARCHAR(512) NOT NULL UNIQUE,
    expires_at DATETIME NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES usuarios(id) ON DELETE CASCADE ON UPDATE CASCADE,
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
```

> Nota: si la tabla ya existe, no es necesario volver a ejecutar este comando.

---

### Ejemplo de petición en Postman: crear una cita de servicio

Endpoint backend:
- Método: `POST`
- URL: `http://localhost:3000/api/citas-servicios` (ajusta el puerto según tu backend)
- Headers recomendados:
  - `Content-Type: application/json`

Body (JSON) de ejemplo:

```json
{
  "nombre": "Angel",
  "email": "cliente@example.com",
  "telefono": "4498489498",
  "direccion": "Calle Ejemplo 123, Colonia Centro",
  "fecha": "2025-11-14T18:38",
  "descripcion": "La computadora se apaga sola y va muy lenta.",
  "servicio_id": 1
}
```

Comportamiento esperado:
- El backend debe:
  - Validar los campos.
  - Crear un registro en la tabla `citas_servicios` con estado inicial `pendiente`.
  - Retornar `201 Created` o `200 OK` con la cita creada en el `body` de la respuesta.

Este mismo formato de JSON es el que se usa cuando el formulario en la página de detalle de un servicio (SPA React) dispara la solicitud al endpoint `/api/citas-servicios`.

---

15-11-2025
- Frontend: se unificó el manejo de imágenes por defecto en el módulo de productos y en los productos destacados de Home.
  - En `Productos.jsx` se usa una imagen placeholder cuando el producto no tiene imagen o la URL falla (onError), evitando íconos de imagen rota.
  - En `Home.jsx` (carrusel de productos destacados) se aplicó la misma lógica de placeholder y onError para `imagen_principal`.

15-11-2025 (actualización Home y Productos)
- Frontend: ajustes en productos destacados (Home) y detalle de productos.
  - En `Home.jsx` se eliminaron los iconos de "ojo" y el texto/botón "Ver Detalles" dentro de cada tarjeta de producto destacado, dejando las cards como elementos visuales limpios.
  - Ahora en `Home.jsx` cada tarjeta de producto destacado es clicable y redirige a `/productos/:id`, reutilizando la misma ruta de detalle que el módulo de productos.
  - En `Productos.jsx` se separó la vista en dos modos:
    - Modo lista (`/productos`): muestra el grid de productos y cada card es clicable para ir al detalle del producto.
    - Modo detalle (`/productos/:id`): muestra solo la información del producto seleccionado (imagen, nombre, precio, stock) usando el endpoint `/api/productos/:id`.
  - Se mantiene el uso de la imagen placeholder cuando falla la carga de la imagen real del producto.

15-11-2025 (detalle de productos: nuevas columnas en `productos`)
- Base de datos: se añadieron campos para soportar descripción detallada y especificaciones en productos.

```sql
USE `nextlevel`;

ALTER TABLE `productos`
  ADD COLUMN `descripcion_corta` VARCHAR(300) NULL AFTER `nombre`,
  ADD COLUMN `descripcion_detallada` TEXT NULL AFTER `descripcion_corta`,
  ADD COLUMN `especificaciones` TEXT NULL AFTER `descripcion_detallada`;
```

15-11-2025 (detalle de productos: imagen principal y carrito)
- Backend:
  - En `backend/models/Productos.js` se actualizó el método `obtenerPorId(id)` para que, además de los campos de `productos`, haga un JOIN con `imagenes_productos` y devuelva la URL de la imagen principal como `imagen_principal`:
    - `SELECT p.*, ip.url AS imagen_principal FROM productos p LEFT JOIN imagenes_productos ip ON p.id = ip.producto_id AND ip.es_principal = 1 WHERE p.id = ? LIMIT 1;`
  - Esto unifica el comportamiento con los listados que ya usaban `imagen_principal` (`obtenerTodosConImagenes`, `obtenerDestacados`, búsqueda) y permite que el detalle de producto tenga acceso a la misma imagen principal.

- Frontend (detalle de productos):
  - En `fronted/src/pages/Productos.jsx` se reforzó la normalización de productos en `normalizeProduct` para construir la imagen principal (`image`) a partir de:
    - `raw.imagen_principal` (prioritario, viene del JOIN con `imagenes_productos`).
    - `raw.imagenes` (array o string con URLs), tomando la primera URL disponible.
    - Compatibilidad adicional con campos `url_imagen` / `url` (cuando el JOIN entrega estos nombres).
    - Si no hay ninguna imagen, se usa un placeholder estándar de `placehold.co`.
  - En el render de detalle (`renderProductDetail`) se muestra esta imagen principal en grande en la columna izquierda:
    - `<img src={image || 'https://placehold.co/600x400/EEE/31343C?text=Producto'} ... onError` para asegurar que nunca se vea un icono de imagen rota.

- Frontend (carrito):
  - En `fronted/src/utils/CartContext.jsx` se ajustó `addToCart` para aceptar `type` y `quantity` genéricos, y se usa `price` para productos (manteniendo compatibilidad con `precio` para otros casos).
  - En `fronted/src/components/Navbar.jsx` se unificó el cálculo del total del carrito utilizando `price` o `precio` según el item:
    - `const unitPrice = Number(i.price ?? i.precio ?? 0);`
    - `const cartTotal = cartItems.reduce((s, i) => s + unitPrice * quantity, 0);`
  - Las imágenes de los items del carrito ahora se muestran usando:
    - `item.image` (productos añadidos desde el detalle), o
    - `item.imagen_url` (servicios, si aplica), con fallback a un placeholder.
    - Se añadió `onError` para asegurar que cualquier URL rota en el carrito también caiga a la imagen por defecto.

- Resultado:
  - El detalle de producto muestra ahora la imagen principal real almacenada en `imagenes_productos` (cuando existe) y solo usa la imagen por defecto cuando no hay ninguna asociada.
  - El carrito muestra correctamente la miniatura de cada producto/servicio y los totales se calculan sin errores, soportando tanto `price` (frontend) como `precio` (backend).
  
 Productos.jsx
 1. Mejoras en el Hook useEffect
 2. Custom Hooks para Separar Responsabilidades
 3. Componentes más Pequeños y Reutilizables
 4. Mejoras en el Manejo de Estados
 5. Optimización de Rendimiento
 6. Mejoras en la Normalización de Datos
 7. Manejo Mejorado de Errores
 8. Implementación Completa Mejorada
 Ventajas obtenidas:Código más legible y mantenible, Mejor separación de responsabilidades, Mayor reutilización de componentes
Mejor rendimiento con memoización, Manejo de errores más robusto, Más fácil de testear.
